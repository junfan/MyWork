====前言

====框架URL
之前商城V3的框架URL是这种格式的，导致的问题是什么呢，我们看这个URL中的参数MUrl
它表示的是mainfra(主要内容iframe)应该指向的链接，这样我们可以用带框架的链接来
定位到某个直接的mainfra，但是有个问题就是如果mainfra URL进行了跳转的话，我们顶部
的链接却不能变，为什么不能变是因为MUrl是一个URL参数而不是Hash参数。

>   http://show.qq.com/show__v3.html?MUrl=http%3A//imgcache.qq.com/qqshow__v3/htdocs/inc/main__f.html

所以新的URL的格式是如下的方式，采用的Hash参数，所以如果主页面的url有变化的话，我们
就可以把它设置到顶层框架页的hash参数里面，这样用户copy这个URL下次就可以定位到主页面
里面相应的URL了

>   http://fashion.show.qq.com/index.html#MUrl%3D/main/index.html

框架URL改动会影响到两个问题，在IE下面可能会把top页面的标题变成很多URL中的Hash，为了修复这个问题
就用了一个setTimeout来循环获取标题子页面标题来设置顶层页的标题。

====框架调整
框架调整主要包括两个方面，一个是浏览器大小变化的时候(resize)，需要切换宽屏或者窄屏模式（主要
是试穿框的展示与隐藏，内容区的大小变化由样式来控制）;另外一个就是框架滚动的时候，需要控制一些
组件的滚动，比如试穿框垂直位置调整，右下角tips位置调整等等。

新框架与老框架不同的一点是，老框架是监听的框架页面的scroll事件。 现在的新框架采取的是框架页面
无滚动条，滚动条为子页面滚动条的方式。这样如果子页面往下滚动页面的时候，我们需要监听页面滚动到
多少了，然后把相应的框架页面的元素（试穿框，导航菜单）等一起往上滚动，其实相对老商城逻辑来说还
是简单了很多，这里设定了一个阈值（顶部菜单的高度），如果超过阈值的话，试穿框就不动了，这个也比
较简单，不过由于是在子页面onload之后加载的事件所以如果子页面onload都没有完成的话，会发现滚动无
效。

====试穿框的处理
老商城的试穿框的展示与隐藏的时候会有一个问题，就是有时候会发现Firefox下面试穿框有时候会变成白板，
这是因为改变包含试穿Flash的容器的position属性以及display属性会导致Flash重新加载导致，表现在浏览器
放大缩小的时候调整了页面的样式（修改试穿框position属性），还有就是隐藏与展示试穿框的时候（修改试穿
框display属性）。V3商城现在的做法是检测到Flash重新加载或者有什么异常情况，就重新执行页面的初始化函
数，这样有一个不好的地方就是让用户感觉会重新load一下，而且代码里面写起来和很乱。本来这次的实现也是
这样，但是后来发现试穿框的div本身就需要开发这边来设置位置，所以就干脆试穿框全部用一个position:absolute
定位，首先这里就规避了修改position属性变化带来的问题。还有就是试穿框使用style.left="-1000px"这样的方式
来达到隐藏的效果，这里就避免了修改style.display属性的问题。

====loadCgi
问题：之前的cgi使用XMLHTTPRequest方式，有两个问题：
1. 跨域需要代理页面，第一次请求某个域名下面的cgi 的时候需要先加载跨域页面;
2. 发起XMLHTTPRequest请求比直接GET方式会速度要慢，这个有一个数据大概慢100ms左右;
3. 返回的数据是XmlDocument，数据的获取比较麻烦。

这次改造遇到的一些问题和大家分享一下:

1. URL长度2083限制，由于还有XMLHTTPRequest的支持，所以我们还是会转向走XMLHTTPRequest，只不过返回的
还是json格式的数据，然后前台eval一下，不知道与加入一个scirpt标签会不会有不一样
2. 接口保持与之前getQQSHOWXML基本一致，改成getQQSHOWJson方式，只不过Json有时候会遇到字符编码问题以及
document的问题，所以使用了对象作为参数的方式。
3. 由于后台确定的接口是返回一个变量数据而不是一个函数调用的方式，所以这里需要随即出一个变量名，之前
用的一个random生成的参数，后来发现在fiddler下面构造返回的时候每次都变不大好，所以为了兼容我们就改成
一个与cgi名字以及URL字符串生成的一个固定数字来构造。
4. 每次请求都加上一个随机参数，确保每次都会请求到服务器而不是拿的本地缓存，虽然也可以在后台通过HTTP头
设置不缓存，但是这里还是前端也确保比较好，函数使用者可以在自己需要缓存的地方缓存数据。
  
====sendPGV的改造
问题：之前有同学说会遇到PVG在HTTPWatch下面会出现abort的问题，其问题本质应该是有一些链接又需要发送
点击流又需要页面跳转，IE下面如果那个请求没那么快的话，页面跳转之后就会把那个点击流的请求Abort掉，之前
有提过两个方案：onkeydown，这个事件会比onclick事件先发生，大概也就那么短的时间，这个问题就解决掉了。
另外一个就是把点击流放在框架页面去做。这次逸之尚就是放在这个里面做的。QSFL.fashion.sendPGV();


====对于形象性别的获取
问题：用户形象性别的确定是根据用户最近一个保存形象的性别来确定的，而这个需要在用户信息处理完之后才能
决定性别到底是什么，之前老商城采取的是setTimeout轮询cookie里面某个字段是否设置了，如果设置了那么就认为
获取avsex字段的值就是性别。这样的坏处就是这样的逻辑不是以一个方法的形式来确定，而是需要用户看代码才知道
这样获取性别。所以这次的改动是提供一个接口，然后开发者把自己的方法通过这个接口来设置，如果性别确定了，
我那个接口就会调用开发者提供的这个方法。这样看起来就简单多了。QSFL.fashion.avSexReady();


====对于coreInfo以及extInfo的内容的依赖
由于新框架页面包括的内容很多，之前的方式就是只要新增功能就提供一个方法，这次改动基本上相当于集成了
sidebar.js(6728),frame.js(1071),header.js(4764)等多个模块，之前这些代码加起来大概有一万行吧，如果把这么
大一个文件还使用这种模式来开发的话，到时候读代码的人肯定想骂人，所以这次把每个内聚的功能点组织成一个模块
使用闭包进行包装，然后这个模块只暴露需要暴露的方法给外界。比如coreInfo以及extInfo这两个cgi信息的获取，
之前是在一个fnSuccss（CGI请求成功回调函数）里面把这些都处理掉了，随着功能的增加，导致这个函数越来越大，
到最后都不好维护了，所以这次设计成了接口回调的形式，每个需要用到这个数据的同学自己去这里去取这个数据。
UserInfo.coreInfoReady 以及 UserInfo.extInfoReady方法。

====分页器的实现
我们之前的分页是写成一个函数的，有一个很大的问题就是分页器自己的逻辑与页面的函数进行绑定了。把分页器的
展现逻辑放在了我们的内容更新上面，这样有一个问题就是有一点不面向对象。其实我们把一个分页器进行抽象出来
之后的功能就是这样的：

有一个初始的页码，有一个总页码，然后展现出来一个界面可以让我翻页，然后通过翻页界面翻页的时候，就需要通过
一个函数来刷新一下我们的内容页面，分页器自己的UI自己搞定，不需要使用者来搞定。有一个争议的地方就是内部页
码索引使用0开始，但是我们cgi的页码好像使用1开始，当时考虑到可能有时候不请求cgi而是直接使用一个长数组里面
的数据的时候我们一般使用0这样的index比较适合程序员的思维。

之前的接口
    QSFL.excore.showQQSHOWPage(iPno, iPall, fnUrl, oParent, objView, objClass);

现在的接口
    QSFL.fashion.Pager.create(content,container);

====性别切换器

====逻辑与UI的分离
把与UI无关的逻辑与UI进行分离，这样的好处是如果UI变化了，而逻辑没有变化，逻辑部分还是可以重用的。

====接口的暴露
> QSFL.fashion.getPageInterface();
名字有点土哈，但是使用这种方式主要是为了能够减少跨页面的直接调用，用一种规范化的方式来调用其它模块的接口。
> QSFL.fashion.getAvInterface(); 
获取av_rebuild.js里面的接口，而不是让接口不知道怎么来的。

====设计思想
模块化，面向对象，而不是方法的堆积，这样可以把模块更加易于代码的移植以及阅读。

在设计模式里面,有一个原则叫做控制反转，也就是依赖倒置，通俗一点的话就是“不要调用我，让我来调用你”。这可能
就是大部分框架提供的一种功能。比如上面的形象的性别数据，如果我们的逻辑去调用这个数据的模式的话，那么就是让
那个对象提供一个方法来确定方法是否OK，如果OK，那么我们这个方法就获取一下性别，否则我们就等待（setTimeout）

如果把这个方式来映射到现实生活中就是这样的，有一个邮局，别人邮寄了东西的话邮局不会通知你，更加不会给你送过来
然后有个人说会给你邮寄东西来，就在这两天，如果你比较急的话，你可能过两个小时，就去邮局看一下，如果没有的话
就回去，直到东西来了，你把它领回家。改变之后的方法就是，邮局提升了服务，东西到了可以通知你，并且可以给你送过来
但是你需要登记一下。所以你就去邮局登记一次，然后东西到了马上也送过来了。

在前端很多需要异步使用到的数据，而且很多地方需要使用到的数据都可以用这种方式来组织代码，这样每个模块内部与外部
的逻辑都会分的比较清晰。

还有一个解决复杂性的通用机制就是使用消息通知以及注册的机制。也就是设计模式里面说的观察者模式，和所谓的事件驱动
机制也是类似的，就是注册一个事件，然后有事件的时候就调用一下某个函数。我们的试穿框里面有一个“撤销重做”的功能，
然后sidebar.js里面有13处调用UndoRedoClass，这里就是在撤销重做有更新的时候，这里就需要更新一下撤销重做两个按钮的
状态，为什么有这么多地方有调用呢，是因为这些调用的地方都可能会影响到内部UndoRedo数据状态，所以下次每一个地方有
这种会影响到UndoRedo数据的状态的时候，都需要再调用一下UndoRedoClass这个方法，但是到最后我们发现在QQSHOWAV里面
就只有三个方法会影响到这个UndoRedo内部状态，那么我们就用一个消息中心的概念，其实和事件的也差不多，然后就在底层
那三个地方触发事件，然后上层就监听一下这个事件，然后如果有这种地方改动的话都会触发这个事件，然后。
